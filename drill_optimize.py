#-------------------------------------------------------------------------------
# Name:         drill_optimize
# Purpose:      Optimize drilling files generated by PCB design software, so the
#               g-code will be generated with the shortest travel path for the
#               CNC tool
#
# Author:       APORTO
#
# Created:      04/04/2018
# Copyright:    (c) APORTO 2018
# Licence:      <your licence>
#
# This script uses pcb-tools library for loading Excellon files: https://github.com/curtacircuitos/pcb-tools
#-------------------------------------------------------------------------------

import sys
import os
import math
import gerber
import time
import numpy as np

header = """;
M48
INCH
T1C0.086614
%
T1
"""

footer = """T0
M30
"""

IMPROVEMENT_THRESHOLD = 0.001

# Calculate the euclidian distance in n-space of the route r traversing cities c, ending at the path start.
#path_distance = lambda r,c: np.sum([np.linalg.norm(c[r[p]]-c[r[p-1]]) for p in range(len(r))])
path_distance = lambda r,c: np.sum([np.linalg.norm(c[r[p+1]]-c[r[p]]) for p in range(len(r)-1)])
# Reverse the order of all elements from element i to element k in array r.
two_opt_swap = lambda r,i,k: np.concatenate((r[0:i],r[k:-len(r)+i-1:-1],r[k+1:len(r)]))

def delta_time(t):
    dt = time.time() - t
    hh = int(dt / 3600)
    mm = dt % 3600
    ss = int(mm % 60)
    mm = int(mm / 60)
    return "%02dh%02dm%02ds" % (hh,mm,ss)

def save_file(route, filename, iteration):
    out_filename, ext = os.path.splitext(os.path.basename(filename))
    out_filename += '_optimized_iteration_' + str(iteration) + ext
    out_filename = os.path.join(os.path.dirname(filename), out_filename)

    with open(out_filename, 'w') as f:
        f.write(header)
        for id in route:
            f.write("X%06dY%06d\n" % (points[id][0] * 10000, points[id][1] * 10000))
        f.write(footer)
    print "\tOptmized Excellon file saved at:", os.path.basename(out_filename)


def two_opt(cities,improvement_threshold, in_filename): # 2-opt Algorithm adapted from https://en.wikipedia.org/wiki/2-opt
    t1 = time.time();
    route = np.arange(cities.shape[0]) # Make an array of row numbers corresponding to cities.
    improvement_factor = 1 # Initialize the improvement factor.
    best_distance = path_distance(route,cities) # Calculate the distance of the initial path.
    iteration = 0
    while improvement_factor > improvement_threshold: # If the route is still improving, keep going!
        t2 = time.time();
        iteration += 1
        print "Starting iteration #" + str(iteration) + "..."
        distance_to_beat = best_distance # Record the distance at the beginning of the loop.
        last_perc = 0
        for swap_first in range(0,len(route)-2): # From each city except the first and last,
            #if swap_first % 10 == 0:
                #print "\t>>point:", swap_first
            perc = int(swap_first * 100 / len(cities))

            if perc % 10 == 0 and perc != last_perc:
                print "\t>> %d%%" % perc
            last_perc = perc
            for swap_last in range(swap_first+1,len(route)): # to each of the cities following,
                #print "last", swap_last
                new_route = two_opt_swap(route,swap_first,swap_last) # try reversing the order of these cities
                new_distance = path_distance(new_route,cities) # and check the total distance with this modification.
                if new_distance < best_distance: # If the path distance is an improvement,
                    route = new_route # make this the accepted best route
                    best_distance = new_distance # and update the distance corresponding to this route.
        improvement_factor = 1 - best_distance/distance_to_beat # Calculate how much the route has improved.
        print "\tIteration done in", delta_time(t2)
        print "\tImprovement factor after this iteration:", improvement_factor, ", Expected factor:",improvement_threshold
        save_file(route, in_filename, iteration)
        print "---------------------------------------------------------------------------------------------------------"


    print "Total time spent on optimization:", delta_time(t1)
    return route # When the route is no longer improving substantially, stop searching and return the route.


def fast(points,improvement_threshold, in_filename): # 2-opt Algorithm adapted from https://en.wikipedia.org/wiki/2-opt
    t1 = time.time();

    # Find point nearest to origin (0,0). This will be the first point on this path
    route = [-1]
    min_distance = 1000000000
    for id1, p1 in enumerate(points):
        distance = math.sqrt(p1[0]**2 + p1[1]**2)
        if distance < min_distance:
            min_distance = distance
            route[0] = id1

    # Find the sequence of points:
    # Starting at the first point, it will find the nearest point, add to the list, then repeat the step for the
    # new added point
    min_distance = 1000000000
    for id1 in xrange(len(points)-1):
        p1 = points[route[-1]]
        min_distance = 1000000000
        next_point = -1
        for id2, p2 in enumerate(points):
            if id2 in route:
                continue
            distance = math.sqrt((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2)
            if distance < min_distance:
                min_distance = distance
                next_point = id2
                p2a = p2
        #print route[-1],":", p1,"->", next_point, ":", p2a, "::", min_distance
        route.append(next_point)

    save_file(route, in_filename, 0)

    print "Total time spent on optimization:", delta_time(t1)
    return route


print '''
----------------------------------------------------------------------------------------------------------------
This script will use Travel Salesman Problem theory to optimize the drilling of a circuit-board on a CNC machine

The script works by:
 - Importing the drilling definitions from an Excellon format file (Generated by a PCB design software)
 - Solves the Travel Salesman problem by using the one out of two different algorithms
 - Saves the optmized data into a new Excellon file

 Please note:
 - The optimization opt-2 algorithm may take a lot of time, depending on the number of holes are defined in the input file
 - The opt-2 algorith runs several times. Each iteration lowers (improves) the path optimization factor
 - The opt-2 algorith runs until an improvement threshold is reached
 - Output file will be saved after every iteraction, so you can stop the script whenever it reachs a good-enough result
 - Current version limitation: Only one tool (hole diameter) for the whole file. The script will load all holes from
   the Excellon file, but ignoring the diameter information. All holes in the output file will have the same diameter

Usage: drill_optimize.py <Excellon format file> [algorithm]
    argument algorithm is optional. Options are "fast" or "opt-2". "fast" is the default
----------------------------------------------------------------------------------------------------------------
'''
if len(sys.argv) >= 2:
    if len(sys.argv) == 3:
        if sys.argv[2] == 'fast':
            algorithm = 0
        elif sys.argv[2] == 'opt-2':
            algorithm = 1
        else:
            print 'Invalid algorithm. Options are "fast" or "opt-2". "fast" is the default, if no algorithm is defined'
            print 'Exiting the script...'
            sys.exit(0)
    else:
        algorithm = 0

    print "Loading Excellon file..."
    in_filename = sys.argv[1]
    f = gerber.read(in_filename)

    points = []
    for p in f.hits:
        points.append(p.position)

    if algorithm == 1:
        print "Searching the best route for %d points using algorithm opt-2. This will take some time..." % (len(points))
        route = two_opt(np.array(points), IMPROVEMENT_THRESHOLD, in_filename)
    else:
        print "Searching a good route for %d points using the fast algorithm (This may be not the shortest route)..." % (len(points))
        route = fast(points, IMPROVEMENT_THRESHOLD, in_filename)
else:
    print '''
    Invalid argument:
        Usage: drill_optimize.py <Excellon format file> [algorithm]
        argument algorithm is optional. Options are "fast" or "opt-2". "fast" is the default

        Exiting the script...
    '''
    sys.exit(0)




